# Database Engine

## üîç Data Model Analysis

Looking at your current structure:

- **Novels** with metadata (author, category, state, description, coverUrl).
- **Chapters** belonging to novels (title, content, novelId).
- **Categories** as separate entities with many-to-many relationship to novels.
- **Relationships**:
  - One-to-Many (Novel ‚Üí Chapters)
  - Many-to-Many (Novel ‚Üî Categories)

## üéØ Why PostgreSQL

Here's why PostgreSQL is a **better suited** choice for smart-novel application:

1. **Strong Relational Structure**:
   - Novel ‚Üî Chapter is a clear parent-child relationship.
   - PostgreSQL excels at foreign keys and referential integrity.
   - Efficient JOIN operations when you need to fetch novels with chapters.
2. **Query Patterns We'll Need**:
   - "Get all chapters for a novel" - Simple JOIN.
   - "Find novels by category" - Many-to-many JOIN through junction table.
   - "Get novel with first/last chapter" - Window functions + JOIN.
   - "Find recently updated novels" - Sorted queries with JOINs.
3. **Future-Proofing**:
   - **Full-text search** on chapter content (PostgreSQL's `tsvector`).
   - **User management** (likely coming) - users, bookmarks, reading progress.
   - **Complex filtering** across novels and chapters.
   - **Aggregations** (chapter counts, reading statistics).
4. **ACID Transactions**.
5. **JSON Support When Needed**.

## üóÑÔ∏è TypeORM Integration

This project uses TypeORM as the ORM for PostgreSQL. Key features:

- **Entities**: Database tables are represented as TypeScript classes with decorators
- **Migrations**: Schema changes are version-controlled through migration files
- **Repository Pattern**: Clean separation between data access and business logic
- **Auto-generated UUIDs**: Primary keys are UUIDs generated by PostgreSQL
- **ISO Timestamps**: All dates are stored as timestamps and returned as ISO strings

## üìù Migrations

‚ö†Ô∏è **ALWAYS CREATE MIGRATION SCRIPTS FOR DATABASE CHANGES** - Even though `synchronize: true` is enabled in development, you must create migration files for all schema changes. This ensures:

- Production deployments have proper migration history.
- Team members can sync database schemas.
- Changes are reversible.
- Database changes are version controlled.

### Migration Commands

```bash
# Create a new empty migration file
npm run migration:create apps/backend/src/migrations/MigrationName

# Generate migration from entity changes (compares entities vs current DB)
npm run migration:generate apps/backend/src/migrations/MigrationName

# Run pending migrations
npm run migration:run

# Revert the last migration
npm run migration:revert

# Show migration status
npm run migration:show
```

### Migration Workflow

1. **Make changes to your entities** (e.g., add/modify fields in `*.entity.ts` files)
2. **Generate or create a migration**:
   - Use `migration:generate` to auto-detect changes
   - Or use `migration:create` for manual migrations
3. **Review the generated migration** - Always check the SQL to ensure it's correct
4. **Test the migration** locally with `migration:run`
5. **Commit the migration file** to version control
6. **In production**, run `migration:run` to apply changes
